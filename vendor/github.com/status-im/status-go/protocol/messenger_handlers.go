//nolint
// Code generated by generate_handlers.go. DO NOT EDIT.
// source: generate_handlers.go

package protocol

import (
        "errors"

	"github.com/golang/protobuf/proto"
	"go.uber.org/zap"

	"github.com/status-im/status-go/protocol/common"
	"github.com/status-im/status-go/protocol/protobuf"
	"github.com/status-im/status-go/protocol/transport"
	v1protocol "github.com/status-im/status-go/protocol/v1"
)

func (m *Messenger) dispatchToHandler(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter, fromArchive bool) error {
	switch msg.ApplicationLayer.Type {
	
           case protobuf.ApplicationMetadataMessage_CHAT_MESSAGE:
		return m.handleChatMessageProtobuf(messageState, protoBytes, msg, filter, fromArchive)
        
           case protobuf.ApplicationMetadataMessage_CONTACT_UPDATE:
		return m.handleContactUpdateProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_MEMBERSHIP_UPDATE_MESSAGE:
		return m.handleMembershipUpdateMessageProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_PAIR_INSTALLATION:
		return m.handleSyncPairInstallationProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_REQUEST_ADDRESS_FOR_TRANSACTION:
		return m.handleRequestAddressForTransactionProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_ACCEPT_REQUEST_ADDRESS_FOR_TRANSACTION:
		return m.handleAcceptRequestAddressForTransactionProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_DECLINE_REQUEST_ADDRESS_FOR_TRANSACTION:
		return m.handleDeclineRequestAddressForTransactionProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_REQUEST_TRANSACTION:
		return m.handleRequestTransactionProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SEND_TRANSACTION:
		return m.handleSendTransactionProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_DECLINE_REQUEST_TRANSACTION:
		return m.handleDeclineRequestTransactionProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_INSTALLATION_CONTACT_V2:
		return m.handleSyncInstallationContactV2Protobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_INSTALLATION_ACCOUNT:
		return m.handleSyncInstallationAccountProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_CONTACT_CODE_ADVERTISEMENT:
		return m.handleContactCodeAdvertisementProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_PUSH_NOTIFICATION_REGISTRATION:
		return m.handlePushNotificationRegistrationProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_PUSH_NOTIFICATION_REGISTRATION_RESPONSE:
		return m.handlePushNotificationRegistrationResponseProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_PUSH_NOTIFICATION_QUERY:
		return m.handlePushNotificationQueryProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_PUSH_NOTIFICATION_QUERY_RESPONSE:
		return m.handlePushNotificationQueryResponseProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_PUSH_NOTIFICATION_REQUEST:
		return m.handlePushNotificationRequestProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_PUSH_NOTIFICATION_RESPONSE:
		return m.handlePushNotificationResponseProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_EMOJI_REACTION:
		return m.handleEmojiReactionProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_GROUP_CHAT_INVITATION:
		return m.handleGroupChatInvitationProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_CHAT_IDENTITY:
		return m.handleChatIdentityProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_COMMUNITY_DESCRIPTION:
		return m.handleCommunityDescriptionProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_COMMUNITY_REQUEST_TO_JOIN:
		return m.handleCommunityRequestToJoinProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_PIN_MESSAGE:
		return m.handlePinMessageProtobuf(messageState, protoBytes, msg, filter, fromArchive)
        
           case protobuf.ApplicationMetadataMessage_EDIT_MESSAGE:
		return m.handleEditMessageProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_STATUS_UPDATE:
		return m.handleStatusUpdateProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_DELETE_MESSAGE:
		return m.handleDeleteMessageProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_INSTALLATION_COMMUNITY:
		return m.handleSyncInstallationCommunityProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_ANONYMOUS_METRIC_BATCH:
		return m.handleAnonymousMetricBatchProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_CHAT_REMOVED:
		return m.handleSyncChatRemovedProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_CHAT_MESSAGES_READ:
		return m.handleSyncChatMessagesReadProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_BACKUP:
		return m.handleBackupProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_ACTIVITY_CENTER_READ:
		return m.handleSyncActivityCenterReadProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_ACTIVITY_CENTER_ACCEPTED:
		return m.handleSyncActivityCenterAcceptedProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_ACTIVITY_CENTER_DISMISSED:
		return m.handleSyncActivityCenterDismissedProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_BOOKMARK:
		return m.handleSyncBookmarkProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_CLEAR_HISTORY:
		return m.handleSyncClearHistoryProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_SETTING:
		return m.handleSyncSettingProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_COMMUNITY_MESSAGE_ARCHIVE_MAGNETLINK:
		return m.handleCommunityMessageArchiveMagnetlinkProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_PROFILE_PICTURES:
		return m.handleSyncProfilePicturesProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_ACCOUNT:
		return m.handleSyncAccountProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_ACCEPT_CONTACT_REQUEST:
		return m.handleAcceptContactRequestProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_RETRACT_CONTACT_REQUEST:
		return m.handleRetractContactRequestProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_COMMUNITY_REQUEST_TO_JOIN_RESPONSE:
		return m.handleCommunityRequestToJoinResponseProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_COMMUNITY_SETTINGS:
		return m.handleSyncCommunitySettingsProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_REQUEST_CONTACT_VERIFICATION:
		return m.handleRequestContactVerificationProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_ACCEPT_CONTACT_VERIFICATION:
		return m.handleAcceptContactVerificationProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_DECLINE_CONTACT_VERIFICATION:
		return m.handleDeclineContactVerificationProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_TRUSTED_USER:
		return m.handleSyncTrustedUserProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_VERIFICATION_REQUEST:
		return m.handleSyncVerificationRequestProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_CONTACT_REQUEST_DECISION:
		return m.handleSyncContactRequestDecisionProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_COMMUNITY_REQUEST_TO_LEAVE:
		return m.handleCommunityRequestToLeaveProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_DELETE_FOR_ME_MESSAGE:
		return m.handleSyncDeleteForMeMessageProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_SAVED_ADDRESS:
		return m.handleSyncSavedAddressProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_COMMUNITY_CANCEL_REQUEST_TO_JOIN:
		return m.handleCommunityCancelRequestToJoinProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_CANCEL_CONTACT_VERIFICATION:
		return m.handleCancelContactVerificationProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_KEYPAIR:
		return m.handleSyncKeypairProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_SOCIAL_LINKS:
		return m.handleSyncSocialLinksProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_ENS_USERNAME_DETAIL:
		return m.handleSyncEnsUsernameDetailProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_COMMUNITY_EVENTS_MESSAGE:
		return m.handleCommunityEventsMessageProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_COMMUNITY_EDIT_SHARED_ADDRESSES:
		return m.handleCommunityEditSharedAddressesProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_ACCOUNT_CUSTOMIZATION_COLOR:
		return m.handleSyncAccountCustomizationColorProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_ACCOUNTS_POSITIONS:
		return m.handleSyncAccountsPositionsProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_COMMUNITY_EVENTS_MESSAGE_REJECTED:
		return m.handleCommunityEventsMessageRejectedProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_COMMUNITY_PRIVILEGED_USER_SYNC_MESSAGE:
		return m.handleCommunityPrivilegedUserSyncMessageProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_COMMUNITY_SHARD_KEY:
		return m.handleCommunityShardKeyProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_CHAT:
		return m.handleSyncChatProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_ACTIVITY_CENTER_DELETED:
		return m.handleSyncActivityCenterDeletedProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_ACTIVITY_CENTER_UNREAD:
		return m.handleSyncActivityCenterUnreadProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_ACTIVITY_CENTER_COMMUNITY_REQUEST_DECISION:
		return m.handleSyncActivityCenterCommunityRequestDecisionProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_TOKEN_PREFERENCES:
		return m.handleSyncTokenPreferencesProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_COMMUNITY_PUBLIC_SHARD_INFO:
		return m.handleCommunityPublicShardInfoProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_COLLECTIBLE_PREFERENCES:
		return m.handleSyncCollectiblePreferencesProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_COMMUNITY_USER_KICKED:
		return m.handleCommunityUserKickedProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_SYNC_PROFILE_SHOWCASE_PREFERENCES:
		return m.handleSyncProfileShowcasePreferencesProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_COMMUNITY_PUBLIC_STORENODES_INFO:
		return m.handleCommunityPublicStorenodesInfoProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_COMMUNITY_REEVALUATE_PERMISSIONS_REQUEST:
		return m.handleCommunityReevaluatePermissionsRequestProtobuf(messageState, protoBytes, msg, filter)
        
           case protobuf.ApplicationMetadataMessage_DELETE_COMMUNITY_MEMBER_MESSAGES:
		return m.handleDeleteCommunityMemberMessagesProtobuf(messageState, protoBytes, msg, filter)
        
	default:
		m.logger.Info("protobuf type not found", zap.String("type", string(msg.ApplicationLayer.Type)))
                return errors.New("protobuf type not found")
	}
	return nil
}


func (m *Messenger) handleChatMessageProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter, fromArchive bool) error {
	m.logger.Info("handling ChatMessage")
	

	
	p := &protobuf.ChatMessage{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleChatMessage(messageState, p, msg, fromArchive )
	
}


func (m *Messenger) handleContactUpdateProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling ContactUpdate")
	

	
	p := &protobuf.ContactUpdate{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleContactUpdate(messageState, p, msg)
	
}


func (m *Messenger) handleMembershipUpdateMessageProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling MembershipUpdateMessage")
	

	
	p := &protobuf.MembershipUpdateMessage{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleMembershipUpdateMessage(messageState, p, msg)
	
}


func (m *Messenger) handleSyncPairInstallationProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncPairInstallation")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncPairInstallation{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncPairInstallation(messageState, p, msg)
	
}


func (m *Messenger) handleRequestAddressForTransactionProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling RequestAddressForTransaction")
	

	
	p := &protobuf.RequestAddressForTransaction{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleRequestAddressForTransaction(messageState, p, msg)
	
}


func (m *Messenger) handleAcceptRequestAddressForTransactionProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling AcceptRequestAddressForTransaction")
	

	
	p := &protobuf.AcceptRequestAddressForTransaction{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleAcceptRequestAddressForTransaction(messageState, p, msg)
	
}


func (m *Messenger) handleDeclineRequestAddressForTransactionProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling DeclineRequestAddressForTransaction")
	

	
	p := &protobuf.DeclineRequestAddressForTransaction{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleDeclineRequestAddressForTransaction(messageState, p, msg)
	
}


func (m *Messenger) handleRequestTransactionProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling RequestTransaction")
	

	
	p := &protobuf.RequestTransaction{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleRequestTransaction(messageState, p, msg)
	
}


func (m *Messenger) handleSendTransactionProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SendTransaction")
	

	
	p := &protobuf.SendTransaction{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSendTransaction(messageState, p, msg)
	
}


func (m *Messenger) handleDeclineRequestTransactionProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling DeclineRequestTransaction")
	

	
	p := &protobuf.DeclineRequestTransaction{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleDeclineRequestTransaction(messageState, p, msg)
	
}


func (m *Messenger) handleSyncInstallationContactV2Protobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncInstallationContactV2")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncInstallationContactV2{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncInstallationContactV2(messageState, p, msg)
	
}


func (m *Messenger) handleSyncInstallationAccountProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncInstallationAccount")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncInstallationAccount{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncInstallationAccount(messageState, p, msg)
	
}


func (m *Messenger) handleContactCodeAdvertisementProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling ContactCodeAdvertisement")
	

	
	p := &protobuf.ContactCodeAdvertisement{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleContactCodeAdvertisement(messageState, p, msg)
	
}


func (m *Messenger) handlePushNotificationRegistrationProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling PushNotificationRegistration")
	

	
	return m.HandlePushNotificationRegistration(messageState, protoBytes, msg)
	
}


func (m *Messenger) handlePushNotificationRegistrationResponseProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling PushNotificationRegistrationResponse")
	

	
	p := &protobuf.PushNotificationRegistrationResponse{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandlePushNotificationRegistrationResponse(messageState, p, msg)
	
}


func (m *Messenger) handlePushNotificationQueryProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling PushNotificationQuery")
	

	
	p := &protobuf.PushNotificationQuery{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandlePushNotificationQuery(messageState, p, msg)
	
}


func (m *Messenger) handlePushNotificationQueryResponseProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling PushNotificationQueryResponse")
	

	
	p := &protobuf.PushNotificationQueryResponse{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandlePushNotificationQueryResponse(messageState, p, msg)
	
}


func (m *Messenger) handlePushNotificationRequestProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling PushNotificationRequest")
	

	
	p := &protobuf.PushNotificationRequest{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandlePushNotificationRequest(messageState, p, msg)
	
}


func (m *Messenger) handlePushNotificationResponseProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling PushNotificationResponse")
	

	
	p := &protobuf.PushNotificationResponse{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandlePushNotificationResponse(messageState, p, msg)
	
}


func (m *Messenger) handleEmojiReactionProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling EmojiReaction")
	

	
	p := &protobuf.EmojiReaction{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleEmojiReaction(messageState, p, msg)
	
}


func (m *Messenger) handleGroupChatInvitationProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling GroupChatInvitation")
	

	
	p := &protobuf.GroupChatInvitation{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleGroupChatInvitation(messageState, p, msg)
	
}


func (m *Messenger) handleChatIdentityProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling ChatIdentity")
	

	
	p := &protobuf.ChatIdentity{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleChatIdentity(messageState, p, msg)
	
}


func (m *Messenger) handleCommunityDescriptionProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling CommunityDescription")
	

	
	p := &protobuf.CommunityDescription{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleCommunityDescription(messageState, p, msg)
	
}


func (m *Messenger) handleCommunityRequestToJoinProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling CommunityRequestToJoin")
	

	
	p := &protobuf.CommunityRequestToJoin{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleCommunityRequestToJoin(messageState, p, msg)
	
}


func (m *Messenger) handlePinMessageProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter, fromArchive bool) error {
	m.logger.Info("handling PinMessage")
	

	
	p := &protobuf.PinMessage{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandlePinMessage(messageState, p, msg, fromArchive )
	
}


func (m *Messenger) handleEditMessageProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling EditMessage")
	

	
	p := &protobuf.EditMessage{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleEditMessage(messageState, p, msg)
	
}


func (m *Messenger) handleStatusUpdateProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling StatusUpdate")
	

	
	p := &protobuf.StatusUpdate{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleStatusUpdate(messageState, p, msg)
	
}


func (m *Messenger) handleDeleteMessageProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling DeleteMessage")
	

	
	p := &protobuf.DeleteMessage{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleDeleteMessage(messageState, p, msg)
	
}


func (m *Messenger) handleSyncInstallationCommunityProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncInstallationCommunity")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncInstallationCommunity{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncInstallationCommunity(messageState, p, msg)
	
}


func (m *Messenger) handleAnonymousMetricBatchProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling AnonymousMetricBatch")
	

	
	p := &protobuf.AnonymousMetricBatch{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleAnonymousMetricBatch(messageState, p, msg)
	
}


func (m *Messenger) handleSyncChatRemovedProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncChatRemoved")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncChatRemoved{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncChatRemoved(messageState, p, msg)
	
}


func (m *Messenger) handleSyncChatMessagesReadProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncChatMessagesRead")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncChatMessagesRead{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncChatMessagesRead(messageState, p, msg)
	
}


func (m *Messenger) handleBackupProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling Backup")
	

	
	p := &protobuf.Backup{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleBackup(messageState, p, msg)
	
}


func (m *Messenger) handleSyncActivityCenterReadProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncActivityCenterRead")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncActivityCenterRead{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncActivityCenterRead(messageState, p, msg)
	
}


func (m *Messenger) handleSyncActivityCenterAcceptedProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncActivityCenterAccepted")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncActivityCenterAccepted{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncActivityCenterAccepted(messageState, p, msg)
	
}


func (m *Messenger) handleSyncActivityCenterDismissedProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncActivityCenterDismissed")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncActivityCenterDismissed{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncActivityCenterDismissed(messageState, p, msg)
	
}


func (m *Messenger) handleSyncBookmarkProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncBookmark")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncBookmark{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncBookmark(messageState, p, msg)
	
}


func (m *Messenger) handleSyncClearHistoryProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncClearHistory")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncClearHistory{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncClearHistory(messageState, p, msg)
	
}


func (m *Messenger) handleSyncSettingProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncSetting")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncSetting{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncSetting(messageState, p, msg)
	
}


func (m *Messenger) handleCommunityMessageArchiveMagnetlinkProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling CommunityMessageArchiveMagnetlink")
	

	
	p := &protobuf.CommunityMessageArchiveMagnetlink{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleCommunityMessageArchiveMagnetlink(messageState, p, msg)
	
}


func (m *Messenger) handleSyncProfilePicturesProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncProfilePictures")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncProfilePictures{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncProfilePictures(messageState, p, msg)
	
}


func (m *Messenger) handleSyncAccountProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncAccount")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncAccount{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncAccount(messageState, p, msg)
	
}


func (m *Messenger) handleAcceptContactRequestProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling AcceptContactRequest")
	

	
	p := &protobuf.AcceptContactRequest{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleAcceptContactRequest(messageState, p, msg)
	
}


func (m *Messenger) handleRetractContactRequestProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling RetractContactRequest")
	

	
	p := &protobuf.RetractContactRequest{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleRetractContactRequest(messageState, p, msg)
	
}


func (m *Messenger) handleCommunityRequestToJoinResponseProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling CommunityRequestToJoinResponse")
	

	
	p := &protobuf.CommunityRequestToJoinResponse{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleCommunityRequestToJoinResponse(messageState, p, msg)
	
}


func (m *Messenger) handleSyncCommunitySettingsProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncCommunitySettings")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncCommunitySettings{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncCommunitySettings(messageState, p, msg)
	
}


func (m *Messenger) handleRequestContactVerificationProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling RequestContactVerification")
	

	
	p := &protobuf.RequestContactVerification{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleRequestContactVerification(messageState, p, msg)
	
}


func (m *Messenger) handleAcceptContactVerificationProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling AcceptContactVerification")
	

	
	p := &protobuf.AcceptContactVerification{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleAcceptContactVerification(messageState, p, msg)
	
}


func (m *Messenger) handleDeclineContactVerificationProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling DeclineContactVerification")
	

	
	p := &protobuf.DeclineContactVerification{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleDeclineContactVerification(messageState, p, msg)
	
}


func (m *Messenger) handleSyncTrustedUserProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncTrustedUser")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncTrustedUser{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncTrustedUser(messageState, p, msg)
	
}


func (m *Messenger) handleSyncVerificationRequestProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncVerificationRequest")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncVerificationRequest{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncVerificationRequest(messageState, p, msg)
	
}


func (m *Messenger) handleSyncContactRequestDecisionProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncContactRequestDecision")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncContactRequestDecision{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncContactRequestDecision(messageState, p, msg)
	
}


func (m *Messenger) handleCommunityRequestToLeaveProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling CommunityRequestToLeave")
	

	
	p := &protobuf.CommunityRequestToLeave{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleCommunityRequestToLeave(messageState, p, msg)
	
}


func (m *Messenger) handleSyncDeleteForMeMessageProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncDeleteForMeMessage")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncDeleteForMeMessage{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncDeleteForMeMessage(messageState, p, msg)
	
}


func (m *Messenger) handleSyncSavedAddressProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncSavedAddress")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncSavedAddress{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncSavedAddress(messageState, p, msg)
	
}


func (m *Messenger) handleCommunityCancelRequestToJoinProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling CommunityCancelRequestToJoin")
	

	
	p := &protobuf.CommunityCancelRequestToJoin{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleCommunityCancelRequestToJoin(messageState, p, msg)
	
}


func (m *Messenger) handleCancelContactVerificationProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling CancelContactVerification")
	

	
	p := &protobuf.CancelContactVerification{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleCancelContactVerification(messageState, p, msg)
	
}


func (m *Messenger) handleSyncKeypairProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncKeypair")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncKeypair{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncKeypair(messageState, p, msg)
	
}


func (m *Messenger) handleSyncSocialLinksProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncSocialLinks")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncSocialLinks{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncSocialLinks(messageState, p, msg)
	
}


func (m *Messenger) handleSyncEnsUsernameDetailProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncEnsUsernameDetail")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncEnsUsernameDetail{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncEnsUsernameDetail(messageState, p, msg)
	
}


func (m *Messenger) handleCommunityEventsMessageProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling CommunityEventsMessage")
	

	
	p := &protobuf.CommunityEventsMessage{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleCommunityEventsMessage(messageState, p, msg)
	
}


func (m *Messenger) handleCommunityEditSharedAddressesProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling CommunityEditSharedAddresses")
	

	
	p := &protobuf.CommunityEditSharedAddresses{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleCommunityEditSharedAddresses(messageState, p, msg)
	
}


func (m *Messenger) handleSyncAccountCustomizationColorProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncAccountCustomizationColor")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncAccountCustomizationColor{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncAccountCustomizationColor(messageState, p, msg)
	
}


func (m *Messenger) handleSyncAccountsPositionsProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncAccountsPositions")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncAccountsPositions{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncAccountsPositions(messageState, p, msg)
	
}


func (m *Messenger) handleCommunityEventsMessageRejectedProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling CommunityEventsMessageRejected")
	

	
	p := &protobuf.CommunityEventsMessageRejected{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleCommunityEventsMessageRejected(messageState, p, msg)
	
}


func (m *Messenger) handleCommunityPrivilegedUserSyncMessageProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling CommunityPrivilegedUserSyncMessage")
	

	
	p := &protobuf.CommunityPrivilegedUserSyncMessage{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleCommunityPrivilegedUserSyncMessage(messageState, p, msg)
	
}


func (m *Messenger) handleCommunityShardKeyProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling CommunityShardKey")
	

	
	p := &protobuf.CommunityShardKey{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleCommunityShardKey(messageState, p, msg)
	
}


func (m *Messenger) handleSyncChatProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncChat")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncChat{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncChat(messageState, p, msg)
	
}


func (m *Messenger) handleSyncActivityCenterDeletedProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncActivityCenterDeleted")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncActivityCenterDeleted{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncActivityCenterDeleted(messageState, p, msg)
	
}


func (m *Messenger) handleSyncActivityCenterUnreadProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncActivityCenterUnread")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncActivityCenterUnread{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncActivityCenterUnread(messageState, p, msg)
	
}


func (m *Messenger) handleSyncActivityCenterCommunityRequestDecisionProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncActivityCenterCommunityRequestDecision")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncActivityCenterCommunityRequestDecision{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncActivityCenterCommunityRequestDecision(messageState, p, msg)
	
}


func (m *Messenger) handleSyncTokenPreferencesProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncTokenPreferences")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncTokenPreferences{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncTokenPreferences(messageState, p, msg)
	
}


func (m *Messenger) handleCommunityPublicShardInfoProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling CommunityPublicShardInfo")
	

	
	p := &protobuf.CommunityPublicShardInfo{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleCommunityPublicShardInfo(messageState, p, msg)
	
}


func (m *Messenger) handleSyncCollectiblePreferencesProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncCollectiblePreferences")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncCollectiblePreferences{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncCollectiblePreferences(messageState, p, msg)
	
}


func (m *Messenger) handleCommunityUserKickedProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling CommunityUserKicked")
	

	
	p := &protobuf.CommunityUserKicked{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleCommunityUserKicked(messageState, p, msg)
	
}


func (m *Messenger) handleSyncProfileShowcasePreferencesProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling SyncProfileShowcasePreferences")
	
	if !common.IsPubKeyEqual(messageState.CurrentMessageState.PublicKey, &m.identity.PublicKey) {
		m.logger.Warn("not coming from us, ignoring")
		return nil
	}
	

	
	p := &protobuf.SyncProfileShowcasePreferences{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleSyncProfileShowcasePreferences(messageState, p, msg)
	
}


func (m *Messenger) handleCommunityPublicStorenodesInfoProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling CommunityPublicStorenodesInfo")
	

	
	p := &protobuf.CommunityPublicStorenodesInfo{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleCommunityPublicStorenodesInfo(messageState, p, msg)
	
}


func (m *Messenger) handleCommunityReevaluatePermissionsRequestProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling CommunityReevaluatePermissionsRequest")
	

	
	p := &protobuf.CommunityReevaluatePermissionsRequest{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleCommunityReevaluatePermissionsRequest(messageState, p, msg)
	
}


func (m *Messenger) handleDeleteCommunityMemberMessagesProtobuf(messageState *ReceivedMessageState, protoBytes []byte, msg *v1protocol.StatusMessage, filter transport.Filter) error {
	m.logger.Info("handling DeleteCommunityMemberMessages")
	

	
	p := &protobuf.DeleteCommunityMemberMessages{}
	err := proto.Unmarshal(protoBytes, p)
	if err != nil {
		return err
	}

	m.outputToCSV(msg.TransportLayer.Message.Timestamp, msg.ApplicationLayer.ID, messageState.CurrentMessageState.Contact.ID, filter.ContentTopic, filter.ChatID, msg.ApplicationLayer.Type, p)

	return m.HandleDeleteCommunityMemberMessages(messageState, p, msg)
	
}


